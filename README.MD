
# ğŸ¬ **Video Streaming Service**

## ğŸš€ **Como Executar**

Para rodar o programa, execute o arquivo principal com o comando:

```bash
python main.py
```

---

## âœ¨ **Funcionalidades**

- ğŸ“š **Consultar biblioteca de conteÃºdo** âœ…
- ğŸ‘¤ **ConfiguraÃ§Ãµes de usuÃ¡rio** âœ…
- ğŸ¤– **RecomendaÃ§Ãµes personalizadas** â˜‘ï¸
- ğŸ“± **Streaming em mÃºltiplos dispositivos** â˜‘ï¸
- âš¡ **OtimizaÃ§Ã£o de banda larga** âœ…
- â­ **Marcar conteÃºdo e histÃ³rico de visualizaÃ§Ã£o** âœ…
- ğŸ“ **RevisÃµes e avaliaÃ§Ãµes de conteÃºdo** â˜‘ï¸
- ğŸ“¢ **IntegraÃ§Ã£o com anÃºncios** âœ…
- ğŸ”’ **Controle parental** âœ… 
- ğŸ‘¥ **Gerenciamento de usuÃ¡rio** âœ…

## ğŸ› ï¸â˜‘ï¸ **RefatoraÃ§Ã£o**

### âš’ï¸ **MudanÃ§as significativas**
- **MudanÃ§a de armazenamento**: Os anÃºncios e mÃ­dias disponÃ­veis agora se encontram num .JSON Ã  parte da lÃ³gica do programa.
- **Melhoria da lÃ³gica de recomendaÃ§Ã£o**: As recomendaÃ§Ãµes do sistema agora sugerem tÃ­tulos similares, e nÃ£o sÃ³ um gÃªnero. AlÃ©m de que, para aqueles que nÃ£o tÃªm histÃ³rico de exibiÃ§Ã£o, ele recomenda os mais "populares".
- **AvaliaÃ§Ã£o**: O usuÃ¡rio, antes de fazer uma avaliaÃ§Ã£o, tem que ter assistido a mÃ­dia em questÃ£o. AlÃ©m disso, agora o sistema possui um ID para cada filme/sÃ©rie; ou seja, para cada tÃ­tulo, hÃ¡ uma avaliaÃ§Ã£o referente Ã  ele. 
- **ServiÃ§o de vÃ¡rios dispositivos**: Assim como num sistema real de streaming, o nÃºmero de aparelhos simultÃ¢neos em execuÃ§Ã£o Ã© limitado. Se o nÃºmero exceder, entÃ£o nao Ã© possÃ­vel iniciar uma sessÃ£o nova. (ImplementaÃ§Ã£o meio inutil, mas meh).
<!-- - ****: 
- ****: 
- ****: 
- ****:  -->

### ğŸ§® **MudanÃ§as menores**
- **TransiÃ§Ãµes**: O tempo de transiÃ§Ã£o entre "telas" era muito grande e custoso. Esse mesmo tempo foi reduzido.
- **Cancelar aÃ§Ã£o**: Apesar do sistema jÃ¡ dar a possibilidade de abortar determinada aÃ§Ã£o, ele nunca informa que vocÃª pode usar o enter para cancelar uma atividade. Esses prints foram implementados. 
- **Perfil Inexistente**: O sistema agora sabe quando um perfil digitado nÃ£o existe, e informa isso ao usuÃ¡rio.
- **HistÃ³rico por perfil**: Em alguns casos, o sistema nÃ£o sabia diferenciar qual perfil havia assistido determinado conteÃºdo; e entÃ£o dava o mesmo histÃ³rio para todos os perfis. 
- **Caixas de texto**: Apenas uma correÃ§Ã£o visual. O programa agora imprime as caixas de informaÃ§Ã£o de modo mais arrumado.

--- 

## ğŸ§± **PadrÃµes criacionais**
- **Singleton**: Aplicado em ```Avaliacoes```, esse padrÃ£o garante que exista somente uma Ãºnica instÃ¢ncia dessa classe em toda a aplicaÃ§Ã£o, o que funciona como um ponto de acesso global para as avaliaÃ§Ãµes de conteÃºdo. Desse modo, qualquer parte do sistema que precisa registrar ou consultar uma avaliaÃ§Ã£o vai estar interagindo com o mesmo e Ãºnico repositÃ³rio de dados, garantindo a consistÃªncia e integridade das informaÃ§Ãµes das reviews. 
- **Factory Method**: Aqui, esse padrÃ£o foi usado na classe ```MidiaFactory``` para centralizar a criaÃ§Ã£o de tipos diferentes de midias. Em vez do cÃ³digo do cliente decidir qual classe instanciar, ele vai somente enviar os dados para a "fÃ¡brica", que analisa o "tipo" de mÃ­dia e retorna o objeto certo. Essa prÃ¡tica desacopla o sistema, o que facilita a adiÃ§Ã£o de novos tipos de conteÃºdos no futuro, jÃ¡ que as mudanÃ§as ficam concentradas somente na fÃ¡brica. 
- **Builder**:  Foi implementado na classe ```UserBuilder``` e serve para simplificar a criaÃ§Ã£o de objetos ```User``` complexos. Ele permite construir o objeto passo a passo atrÃ¡ves de mÃ©todos encadeados, como ```com_nome()``` e ```com_email()```, sendo finalizada com o mÃ©todo ```build()```. Aqui nÃ³s separamos a lÃ³gica de construÃ§Ã£o do objeto final, o que torna a criaÃ§Ã£o de novos usuÃ¡rios mais legÃ­vel e mais organizada, especialmente quando Ã© para se lidar com mÃºltiplos atributos e regras de validaÃ§Ã£o.
<!-- - ****: -->

---
## ğŸ‘¤ **PadrÃµes comportamentais**
- **Observer**: Criei para ele um novo arquivo. Ele Ã© um padrÃ£o ideal para situaÃ§Ãµes em que uma mudanÃ§a de estado em um objeto deva notificar e atualizar automaticamente outros objetos dependentes. Ele foi aplicado no sistema de gerenciamento de planos de assinatura. Quando um usuÃ¡rio (que Ã© o sujeito) muda o Plano, os objetos (como o StreamingSession, por exemplo) e a BandaLarga vÃ£o ser automaticamente modificados e podem reagir Ã s mudanÃ§as feitas.
- **Strategy**: Esse padrÃ£o permite que se possa definir uma famÃ­lia de algoritmos, encaplusar cada um deles e tornÃ¡-los intercambiÃ¡veis. Aqui, ele era perfeito para o sistema de recomendaÃ§Ãµes, jÃ¡ que ao invÃ©s de se ter uma Ãºnica lÃ³gica de recomendaÃ§Ã£o, a gente criou estratÃ©gias diferentes (baseada no gÃªnero, tendÃªncias, ou atÃ© mesmo aleatÃ³ria) que podem ser trocadas, dando mais flexibilidade ao sistema e ao usuÃ¡rio.
- **State**: A implementaÃ§Ã£o do padrÃ£o State agora permite que um objeto (que nesse caso aqui Ã© o player de vÃ­deo) mude seu comportamento quando seu estado interno muda. O player vai se comportar de maneira diferente se ele estÃ¡: Tocando ou pausando. Esse padrÃ£o organiza essa lÃ³gica de uma forma lÃ­mpa e extensÃ­vel, o que elimina a necessidade de grandes blocos de if/elif.
---

## ğŸ¢ **PadrÃµes estruturais**
- **Decorator**: Pelo fato do sistema ter diferentes tipos de mÃ­dias o decorator permite adicionar novas responsabilidades ou caracterÃ­sticas a objetos dinamicamente, como se estivesse os embrulhando em classes decoradoras.
- **Adapter**: A funÃ§Ã£o todas_as_mÃ­dias() carrega dados de um json, que tem uma estrutura especÃ­fica (tipo "tÃ­tulo", "gÃªnero"). Esse novo padrÃ£o vai permitir que o sistema trabalhe com outras fontes de dados que possuam interfaces incompatÃ­veis.
- **Facade**: Esse rapazinho fornece uma interface unificada e simplificada para um conjunto complexo de interfaces em um subsistema.
<!-- - ****: -->

---
## ğŸ—ï¸ **Estrutura de Projeto**

### ğŸ›ï¸ **Classes:**

- **User**: Template para ministrar, administrar e utilizar diferentes usuÃ¡rios.
- **Perfil**: Template para diferentes perfis em cada usuÃ¡rio distinto.
- **ConjuntoMidias**: Template onde teremos todos os tipos de mÃ­dia possÃ­veis e a partir delas realizar funÃ§Ãµes como explorar o conteÃºdo.
- **Midia**: Template que terÃ¡ diversas outras subclasses referentes ao tipo de mÃ­dia, alÃ©m de funÃ§Ãµes bÃ¡sicas como exibir informaÃ§Ãµes de tal mÃ­dia.

  **Subclasses de MÃ­dia:**
  - **Filme**: Para mÃ­dias que sÃ£o filmes.
  - **Documentario**: Para mÃ­dias que sÃ£o documentÃ¡rios.
  - **Serie**: Para mÃ­dias que sÃ£o sÃ©ries.
  - **Anime**: Para mÃ­dias que sÃ£o animes.
  - **Novela**: Para mÃ­dias que sÃ£o novelas.
  - **Historico**: Realiza o controle do histÃ³rico de exibiÃ§Ã£o, permitindo funcionalidades como limpar histÃ³rico ou acessÃ¡-lo para cada perfil (vai ser um objeto de um atributo da classe Perfil).

- **Recomendacoes**: Template para sugerir conteÃºdos especÃ­ficos baseado no gÃªnero assistido pelo perfil (vai ser um objeto de um atributo da classe Perfil).
- **Anuncio**: Template para fazer a organizaÃ§Ã£o e manuntenÃ§Ã£o de anÃºncios na plataforma de acordo com o plano 
- **Marcar**: Template para marcar conteÃºdos especÃ­ficos para assistir mais tarde e influenciar na recomendaÃ§Ã£o do usuÃ¡rio
- **Plano**: Template para melhorar o gerenciamento de plano com pagamentos e ser utilizado no user_management, alÃ©m de influenciar na parte dos anÃºncios devido ao plano escolhido com regras pre-estabelecidas;
- **Devices**: Template para a organizaÃ§Ã£o de streaming em multiplataforma;
- **BandaLarga**: Template para a manuntenÃ§Ã£o da banda larga e a qualidade da transmissÃ£o enquanto a pessoa assiste;
- **Avaliacoes**: Template para avaliaÃ§Ãµes e reviews sobre um certo conteÃºdo em uma mini-rede social;



